'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _bottleneck = require('bottleneck');

var _bottleneck2 = _interopRequireDefault(_bottleneck);

var _defaults = require('defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _queue = require('./queue');

var _queue2 = _interopRequireDefault(_queue);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug3.default)('winston-aws-cloudwatch:Relay');

var Relay = function (_EventEmitter) {
  (0, _inherits3.default)(Relay, _EventEmitter);

  function Relay(client, options) {
    (0, _classCallCheck3.default)(this, Relay);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Relay.__proto__ || (0, _getPrototypeOf2.default)(Relay)).call(this));

    debug('constructor', { client, options });
    _this._client = client;
    _this._options = (0, _defaults2.default)(options, {
      submissionInterval: 2000,
      batchSize: 20
    });
    _this._limiter = null;
    _this._queue = null;
    return _this;
  }

  (0, _createClass3.default)(Relay, [{
    key: 'start',
    value: function start() {
      debug('start');
      if (this._queue) {
        throw new Error('Already started');
      }
      this._limiter = new _bottleneck2.default(1, this._options.submissionInterval, 1);
      this._queue = new _queue2.default();
      // Initial call to postpone first submission
      this._limiter.schedule(function () {
        return _promise2.default.resolve();
      });
    }
  }, {
    key: 'submit',
    value: function submit(item) {
      this._queue.push(item);
      this._scheduleSubmission();
    }
  }, {
    key: '_scheduleSubmission',
    value: function _scheduleSubmission() {
      var _this2 = this;

      debug('scheduleSubmission');
      this._limiter.schedule(function () {
        return _this2._submit();
      });
    }
  }, {
    key: '_submit',
    value: function _submit() {
      var _this3 = this;

      if (this._queue.size === 0) {
        debug('submit: queue empty');
        return _promise2.default.resolve();
      }
      var batch = this._queue.head(this._options.batchSize);
      debug(`submit: submitting ${batch.length} item(s)`);
      return this._client.submit(batch).then(function () {
        return _this3._onSubmitted(batch);
      }, function (err) {
        return _this3._onError(err, batch);
      }).then(function () {
        return _this3._scheduleSubmission();
      });
    }
  }, {
    key: '_onSubmitted',
    value: function _onSubmitted(batch) {
      debug('onSubmitted', { batch });
      this._queue.remove(batch.length);
      for (var i = 0; i < batch.length; ++i) {
        var item = batch[i];
        item.callback(null, true);
      }
    }
  }, {
    key: '_onError',
    value: function _onError(err, batch) {
      debug('onError', { error: err });
      // Expected errors:
      // - DataAlreadyAcceptedException
      //   Message: "The given batch of log events has already been accepted."
      //   Action: Assume the request got replayed and remove the batch.
      // - InvalidSequenceTokenException
      //   Message: "The given sequenceToken is invalid."
      //   Action: Keep the items in the queue and retry next time.
      if (err.code === 'DataAlreadyAcceptedException') {
        this._queue.remove(batch.length);
      } else if (err.code !== 'InvalidSequenceTokenException') {
        this.emit('error', err);
      }
    }
  }]);
  return Relay;
}(_events.EventEmitter);

exports.default = Relay;