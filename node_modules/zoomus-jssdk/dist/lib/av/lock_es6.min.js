const UNLOCKED=0;const LOCKED_NO_WAITERS=1;const LOCKED_POSSIBLE_WAITERS=2;const NUMINTS=1;class Lock{constructor(t,o){if(!(t instanceof Int32Array&&o|0===o&&o>=0&&o+NUMINTS<=t.length)){throw new Error(`Bad arguments to Lock constructor: ${t} ${o}`)}this.iab=t;this.ibase=o}static initialize(t,o){if(!(t instanceof Int32Array&&o|0===o&&o>=0&&o+NUMINTS<=t.length)){throw new Error(`Bad arguments to Lock constructor: ${t} ${o}`)}Atomics.store(t,o,UNLOCKED);return o}lock(){const t=this.iab;const o=this.ibase;var s;if((s=Atomics.compareExchange(t,o,UNLOCKED,LOCKED_NO_WAITERS))!==UNLOCKED){do{if(s===LOCKED_POSSIBLE_WAITERS||Atomics.compareExchange(t,o,LOCKED_NO_WAITERS,LOCKED_POSSIBLE_WAITERS)!==UNLOCKED){Atomics.wait(t,o,LOCKED_POSSIBLE_WAITERS,Number.POSITIVE_INFINITY)}}while((s=Atomics.compareExchange(t,o,UNLOCKED,LOCKED_POSSIBLE_WAITERS))!==UNLOCKED)}}tryLock(){const t=this.iab;const o=this.ibase;return Atomics.compareExchange(t,o,UNLOCKED,LOCKED_NO_WAITERS)===UNLOCKED}unlock(){const t=this.iab;const o=this.ibase;var s=Atomics.sub(t,o,1);if(s!==LOCKED_NO_WAITERS){Atomics.store(t,o,UNLOCKED);Atomics.wake(t,o,1)}}toString(){return"Lock:{ibase:"+this.ibase+"}"}}